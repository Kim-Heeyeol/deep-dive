---
sidebar_position: 21
---

# javaScript에서의 this

- this를 사용한 경험이 거의 없음
- 이유는 생성자 함수와 클래스 문법을 거의 쓰지 않았기 때문
- 그래서 "this"는 기술 면접을 위한 암기 과목에 불과했음
- 그래서 "왜" this를 쓰며, "왜" this는

- 생성자 함수와 클래스

  둘 다 객체 생성 매커니즘.

  - 생성자 함수

    new 연산자 없이 호출하면 일반 함수로서 호출되기 때문에 별도 처리 필요
    생성자 함수는 extends, super 키워드 미제공
    함수 선언문으로 정의된 생성자 함수는 함수 자체가 호이스팅이 됨
    함수 표현식으로 정의된 생성자 함수는 변수 호이스팅이 발생
    암묵적으로 strict mode가 지정되지 않음

  - 클래스

    new연산자 없이 호출하면 에러 발생
    상속을 지원하는 extends, super 키워드 제공
    호이스팅이 발생하지 않는 것처럼 동작
    모든 코드에는 암묵적으로 strict mode가 지정되어 실행되며 strict mode 해제 불가
    생성자 함수 기반의 객체 생성 방식보다 견고하고 명료함

# 23장 실행 컨텍스트

- 실행 컨텍스트을 이해하면 식별자, 식별자에 바인딩된 값을 관리하는 방식, 호이스팅이 발생하는 이유,
  클로저의 동작 방식, 태스크 큐와 함께 동작하는 이벤트 핸들러, 비동기 처리의 방식을 이해할 수 있다.

### 코드 예시

```js
const x = 1;

function foo() {
  const y = 2;

  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo();
```

### 실행 컨텍스트와 소스코드 평가, 실행 과정

1. 전역 코드가 평가되어 전역 실행 컨텍스트 형성
2. 실행 컨택스트 스택에 푸시
3. 전역 변수 x와 함수 foo는 전역 실행 컨텍스트에 등록
4. 전역 코드가 실행되고 전역 변수 x에 값이 할당
5. foo()가 호출되고, 전역 코드의 실행은 일시 중지
6. foo 함수 코드가 평가되어 함수 실행 컨텍스트 형성
7. 실행 컨텍스트 스택에 푸시
8. foo함수의 지역 변수 y와 중첩함수 bar는 함수 실행 컨텍스트에 등록
9. foo함수가 실행되고 지역 변수 y에 값이 할당
10. bar()가 호출되고, foo함수의 실행은 일시 중지
11. bar함수 코드가 평가되어 함수 실행 컨텍스트 형성
12. 실행 컨텍스트 스택에 푸시
13. 지역변수 z가 bar함수 실행 컨텍스트에 등록
14. bar함수가 실행되고 지역 변수 z에 값이 할당되고, console.log 메서드 호출
15. bar 함수 종료 및 bar 함수 실행 컨텍스트 제거
16. foo 함수 종료 및 foo 함수 실행 컨텍스트 제거
17. 전역 실행 컨텍스트 제거
